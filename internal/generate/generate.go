package generate

/*
#cgo CFLAGS: -std=c99
#include "apriltag.h"
#include "tag36h11.h"
*/
import "C"

import (
	"archive/zip"
	"bufio"
	"errors"
	"flag"
	"fmt"
	"image"
	"image/png"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"unsafe"
)

const (
	defaultOutput    = "output.png"
	defaultOutput3MF = "output.3mf"
	scaleFactor      = 32
)

type outputFlag struct {
	value string
	set   bool
}

func (o *outputFlag) String() string {
	return o.value
}

func (o *outputFlag) Set(v string) error {
	o.value = v
	o.set = true
	return nil
}

func RunGenerate(args []string) error {
	fs := flag.NewFlagSet("generate", flag.ContinueOnError)
	output := &outputFlag{value: defaultOutput}
	fs.Var(output, "o", "output filename")
	stdout := fs.Bool("stdout", false, "print tag pixels to stdout instead of PNG")
	openscad := fs.Bool("openscad", false, "print OpenSCAD source to stdout instead of PNG")
	threeMF := fs.Bool("3mf", false, "write 3MF with separate base/pixel bodies")
	if err := fs.Parse(args); err != nil {
		return err
	}
	if fs.NArg() != 1 {
		return fmt.Errorf("usage: oneil generate [-o file] <id>")
	}

	id, err := strconv.Atoi(fs.Arg(0))
	if err != nil || id < 0 {
		return errors.New("tag id must be a non-negative integer")
	}
	if (*stdout && *openscad) || (*stdout && *threeMF) || (*openscad && *threeMF) {
		return errors.New("choose only one of --stdout, --openscad, or --3mf")
	}
	if *threeMF && !output.set {
		output.value = defaultOutput3MF
	}
	if !*stdout && !*openscad && !*threeMF && output.value == "" {
		return errors.New("output filename must not be empty")
	}

	return generateTag(id, output.value, *stdout, *openscad, *threeMF)
}

func generateTag(id int, outputPath string, stdout bool, openscad bool, threeMF bool) error {
	tf := C.gen_tag36h11_create()
	if tf == nil {
		return errors.New("failed to create tag family")
	}
	defer C.gen_tag36h11_destroy(tf)

	if id >= int(tf.ncodes) {
		return fmt.Errorf("tag id %d out of range (max %d)", id, int(tf.ncodes)-1)
	}

	im := C.gen_apriltag_to_image(tf, C.uint32_t(id))
	if im == nil {
		return errors.New("failed to render tag image")
	}
	defer C.gen_image_u8_destroy(im)

	width := int(im.width)
	height := int(im.height)
	stride := int(im.stride)
	if width <= 0 || height <= 0 || stride < width {
		return errors.New("invalid tag image dimensions")
	}

	buf := unsafe.Slice((*byte)(unsafe.Pointer(im.buf)), height*stride)
	if stdout {
		return renderASCII(buf, width, height, stride, os.Stdout)
	}
	if openscad {
		return renderOpenSCAD(buf, width, height, stride, os.Stdout)
	}
	if threeMF {
		return render3MF(buf, width, height, stride, outputPath)
	}

	scaled := image.NewGray(image.Rect(0, 0, width*scaleFactor, height*scaleFactor))
	for y := 0; y < height; y++ {
		row := buf[y*stride : y*stride+width]
		for x := 0; x < width; x++ {
			v := row[x]
			startX := x * scaleFactor
			startY := y * scaleFactor
			for yy := 0; yy < scaleFactor; yy++ {
				line := scaled.Pix[(startY+yy)*scaled.Stride+startX : (startY+yy)*scaled.Stride+startX+scaleFactor]
				for i := range line {
					line[i] = v
				}
			}
		}
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	if err := png.Encode(file, scaled); err != nil {
		return err
	}

	return nil
}

func renderASCII(buf []byte, width, height, stride int, output *os.File) error {
	writer := bufio.NewWriter(output)
	defer writer.Flush()

	for y := 0; y < height; y++ {
		row := buf[y*stride : y*stride+width]
		for x := 0; x < width; x++ {
			if row[x] > 0 {
				if _, err := writer.WriteString("W"); err != nil {
					return err
				}
			} else {
				if _, err := writer.WriteString("B"); err != nil {
					return err
				}
			}
		}
		if _, err := writer.WriteString("\n"); err != nil {
			return err
		}
	}

	return nil
}

func renderOpenSCAD(buf []byte, width, height, stride int, output *os.File) error {
	const (
		baseThickness = 3.0
		pixelHeight   = 1.0
		tagSize       = 25.0
		colorWhite    = "white"
		colorBlack    = "black"
	)

	pixelSize := tagSize / float64(width)
	writer := bufio.NewWriter(output)
	defer writer.Flush()

	fmt.Fprintf(writer, "// Generated by oneil generate --openscad\n")
	fmt.Fprintf(writer, "tag_size = %.6f;\n", tagSize)
	fmt.Fprintf(writer, "pixel = %.6f;\n", pixelSize)
	fmt.Fprintf(writer, "base_thickness = %.6f;\n", baseThickness)
	fmt.Fprintf(writer, "pixel_height = %.6f;\n\n", pixelHeight)

	fmt.Fprintf(writer, "color(\"%s\") cube([tag_size, tag_size, base_thickness]);\n", colorWhite)
	fmt.Fprintf(writer, "\n")
	fmt.Fprintf(writer, "// Pixel layer is a separate top-level body for multi-color export.\n")
	fmt.Fprintf(writer, "color(\"%s\") union() {\n", colorBlack)
	for y := 0; y < height; y++ {
		row := buf[y*stride : y*stride+width]
		for x := 0; x < width; x++ {
			if row[x] != 0 {
				continue
			}
			xPos := float64(x) * pixelSize
			yPos := float64(height-1-y) * pixelSize
			fmt.Fprintf(writer, "  translate([%.6f, %.6f, base_thickness]) cube([pixel, pixel, pixel_height]);\n",
				xPos, yPos)
		}
	}
	fmt.Fprintf(writer, "}\n")

	return nil
}

type mesh struct {
	vertices  []vertex
	triangles []triangle
}

type vertex struct {
	x float64
	y float64
	z float64
}

type triangle struct {
	v1 int
	v2 int
	v3 int
}

func render3MF(buf []byte, width, height, stride int, outputPath string) error {
	const (
		baseThickness = 3.0
		pixelHeight   = 1.0
		tagSize       = 25.0
	)

	pixelSize := tagSize / float64(width)
	baseMesh := mesh{}
	addCube(&baseMesh, 0, 0, 0, tagSize, tagSize, baseThickness)

	pixelMesh := mesh{}
	for y := 0; y < height; y++ {
		row := buf[y*stride : y*stride+width]
		for x := 0; x < width; x++ {
			if row[x] != 0 {
				continue
			}
			xPos := float64(x) * pixelSize
			yPos := float64(height-1-y) * pixelSize
			addCube(&pixelMesh, xPos, yPos, baseThickness, pixelSize, pixelSize, pixelHeight)
		}
	}

	if len(pixelMesh.triangles) == 0 {
		return errors.New("no black pixels to render")
	}

	return write3MF(outputPath, baseMesh, pixelMesh)
}

func addCube(m *mesh, x, y, z, dx, dy, dz float64) {
	base := len(m.vertices)
	m.vertices = append(m.vertices,
		vertex{x, y, z},
		vertex{x + dx, y, z},
		vertex{x + dx, y + dy, z},
		vertex{x, y + dy, z},
		vertex{x, y, z + dz},
		vertex{x + dx, y, z + dz},
		vertex{x + dx, y + dy, z + dz},
		vertex{x, y + dy, z + dz},
	)

	addTri := func(a, b, c int) {
		m.triangles = append(m.triangles, triangle{base + a, base + b, base + c})
	}

	// Bottom
	addTri(0, 1, 2)
	addTri(0, 2, 3)
	// Top
	addTri(4, 6, 5)
	addTri(4, 7, 6)
	// Front
	addTri(0, 4, 5)
	addTri(0, 5, 1)
	// Right
	addTri(1, 5, 6)
	addTri(1, 6, 2)
	// Back
	addTri(2, 6, 7)
	addTri(2, 7, 3)
	// Left
	addTri(3, 7, 4)
	addTri(3, 4, 0)
}

func write3MF(path string, baseMesh, pixelMesh mesh) error {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}

	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	zipWriter := zip.NewWriter(file)
	if err := writeZipEntry(zipWriter, "[Content_Types].xml", contentTypesXML()); err != nil {
		zipWriter.Close()
		return err
	}
	if err := writeZipEntry(zipWriter, "_rels/.rels", relsXML()); err != nil {
		zipWriter.Close()
		return err
	}
	if err := writeZipEntry(zipWriter, "3D/3dmodel.model", modelXML(baseMesh, pixelMesh)); err != nil {
		zipWriter.Close()
		return err
	}

	return zipWriter.Close()
}

func writeZipEntry(z *zip.Writer, name, contents string) error {
	header := &zip.FileHeader{
		Name:   name,
		Method: zip.Deflate,
	}
	writer, err := z.CreateHeader(header)
	if err != nil {
		return err
	}
	_, err = writer.Write([]byte(contents))
	return err
}

func contentTypesXML() string {
	return strings.TrimSpace(`<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/>
</Types>`) + "\n"
}

func relsXML() string {
	return strings.TrimSpace(`<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" Target="/3D/3dmodel.model"/>
</Relationships>`) + "\n"
}

func modelXML(baseMesh, pixelMesh mesh) string {
	var b strings.Builder
	b.WriteString(`<?xml version="1.0" encoding="UTF-8"?>` + "\n")
	b.WriteString(`<model unit="millimeter" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02">` + "\n")
	b.WriteString("  <resources>\n")
	writeObjectXML(&b, 1, "base", baseMesh)
	writeObjectXML(&b, 2, "pixels", pixelMesh)
	writeAssemblyXML(&b, 3, "oneil", []int{1, 2})
	b.WriteString("  </resources>\n")
	b.WriteString("  <build>\n")
	b.WriteString(`    <item objectid="3"/>` + "\n")
	b.WriteString("  </build>\n")
	b.WriteString("</model>\n")
	return b.String()
}

func writeObjectXML(b *strings.Builder, id int, name string, m mesh) {
	fmt.Fprintf(b, "    <object id=\"%d\" name=\"%s\" type=\"model\">\n", id, name)
	b.WriteString("      <mesh>\n")
	b.WriteString("        <vertices>\n")
	for _, v := range m.vertices {
		fmt.Fprintf(b, "          <vertex x=\"%.6f\" y=\"%.6f\" z=\"%.6f\"/>\n", v.x, v.y, v.z)
	}
	b.WriteString("        </vertices>\n")
	b.WriteString("        <triangles>\n")
	for _, t := range m.triangles {
		fmt.Fprintf(b, "          <triangle v1=\"%d\" v2=\"%d\" v3=\"%d\"/>\n", t.v1, t.v2, t.v3)
	}
	b.WriteString("        </triangles>\n")
	b.WriteString("      </mesh>\n")
	b.WriteString("    </object>\n")
}

func writeAssemblyXML(b *strings.Builder, id int, name string, components []int) {
	fmt.Fprintf(b, "    <object id=\"%d\" name=\"%s\" type=\"model\">\n", id, name)
	b.WriteString("      <components>\n")
	for _, componentID := range components {
		fmt.Fprintf(b, "        <component objectid=\"%d\" transform=\"1 0 0 0 1 0 0 0 1 0 0 0\"/>\n", componentID)
	}
	b.WriteString("      </components>\n")
	b.WriteString("    </object>\n")
}
